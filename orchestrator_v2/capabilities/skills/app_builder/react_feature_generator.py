"""
React Feature Generator skill.

Generates new pages and features for existing React applications.
"""

import re
from pathlib import Path

from .models import FeatureGeneratorInput, FeatureGeneratorOutput


class ReactFeatureGenerator:
    """Skill for generating React features and pages."""

    def __init__(self):
        self.skill_id = "react_feature_generator"
        self.description = "Generate new pages and features for React applications"

    def execute(self, input_data: FeatureGeneratorInput) -> FeatureGeneratorOutput:
        """Execute the feature generation."""
        output = FeatureGeneratorOutput()
        repo_path = Path(input_data.repo_path)

        try:
            # Derive component name from description if not provided
            if input_data.component_name:
                component_name = input_data.component_name
            else:
                component_name = self._derive_component_name(input_data.feature_description)

            output.component_name = component_name

            # Derive route from component name if not provided
            if input_data.target_route:
                route_path = input_data.target_route
            else:
                route_path = f"/{component_name.lower().replace('page', '')}"

            output.route_path = route_path

            # Create the page component
            self._create_page_component(repo_path, component_name, input_data, output)

            # Create associated components if needed
            self._create_associated_components(repo_path, component_name, input_data, output)

            # Update App.tsx routing
            self._update_routing(repo_path, component_name, route_path, output)

            # Create tests if requested
            if input_data.include_tests:
                self._create_tests(repo_path, component_name, output)

            # Generate commit message
            output.commit_message = f"feat: add {component_name} page at {route_path}"
            output.success = True

        except Exception as e:
            output.success = False
            output.errors.append(str(e))

        return output

    def _derive_component_name(self, description: str) -> str:
        """Derive a component name from the feature description."""
        # Extract key words and create PascalCase name
        words = re.findall(r'\b\w+\b', description.lower())

        # Filter common words and take first few significant ones
        stop_words = {'a', 'an', 'the', 'for', 'to', 'of', 'and', 'or', 'with', 'that', 'this'}
        significant = [w for w in words if w not in stop_words][:3]

        # Convert to PascalCase
        name = ''.join(word.capitalize() for word in significant)

        # Ensure it ends with 'Page' if it's a page
        if not name.endswith('Page'):
            name += 'Page'

        return name

    def _create_page_component(
        self,
        repo_path: Path,
        component_name: str,
        input_data: FeatureGeneratorInput,
        output: FeatureGeneratorOutput
    ) -> None:
        """Create the main page component."""

        # State imports if needed
        state_import = "import { useState } from 'react'" if input_data.include_state else ""
        state_hook = """
  const [loading, setLoading] = useState(false)
  const [data, setData] = useState<unknown>(null)
""" if input_data.include_state else ""

        page_content = f'''import React from 'react'
{state_import}

interface {component_name}Props {{
  // Add props here
}}

const {component_name}: React.FC<{component_name}Props> = () => {{
{state_hook}
  return (
    <div className="page {component_name.lower().replace('page', '')}-page">
      <h2>{component_name.replace('Page', '')}</h2>
      <p>{input_data.feature_description}</p>

      {{/* Add your feature content here */}}
      <div className="feature-content">
        <p>This page was generated by RSC App Builder.</p>
      </div>
    </div>
  )
}}

export default {component_name}
'''

        page_path = repo_path / "src" / "pages" / f"{component_name}.tsx"
        page_path.parent.mkdir(parents=True, exist_ok=True)
        page_path.write_text(page_content)
        output.files_created.append(f"src/pages/{component_name}.tsx")

    def _create_associated_components(
        self,
        repo_path: Path,
        component_name: str,
        input_data: FeatureGeneratorInput,
        output: FeatureGeneratorOutput
    ) -> None:
        """Create any associated smaller components."""
        # For now, create a placeholder component that could be used
        base_name = component_name.replace('Page', '')

        component_content = f'''import React from 'react'

interface {base_name}ContentProps {{
  title?: string
  children?: React.ReactNode
}}

export const {base_name}Content: React.FC<{base_name}ContentProps> = ({{
  title = '{base_name}',
  children
}}) => {{
  return (
    <div className="{base_name.lower()}-content card">
      <h3 className="card-title">{{title}}</h3>
      <div className="card-body">
        {{children}}
      </div>
    </div>
  )
}}
'''

        component_path = repo_path / "src" / "components" / f"{base_name}Content.tsx"
        component_path.parent.mkdir(parents=True, exist_ok=True)
        component_path.write_text(component_content)
        output.files_created.append(f"src/components/{base_name}Content.tsx")

    def _update_routing(
        self,
        repo_path: Path,
        component_name: str,
        route_path: str,
        output: FeatureGeneratorOutput
    ) -> None:
        """Update App.tsx with new route."""
        app_path = repo_path / "src" / "App.tsx"

        if not app_path.exists():
            output.errors.append("App.tsx not found - routing not updated")
            return

        content = app_path.read_text()

        # Add import if not present
        import_statement = f"import {component_name} from './pages/{component_name}'"
        if import_statement not in content:
            # Find last import and add after it
            import_pattern = r"(import .+ from '.+'\n)(?!import)"
            match = re.search(import_pattern, content)
            if match:
                insert_pos = match.end()
                content = content[:insert_pos] + f"{import_statement}\n" + content[insert_pos:]

        # Add route if not present
        route_statement = f'<Route path="{route_path}" element={{<{component_name} />}} />'
        if route_statement not in content:
            # Find Routes closing tag and add before it
            routes_pattern = r'(\s*)</Routes>'
            replacement = f'        {route_statement}\n\\1</Routes>'
            content = re.sub(routes_pattern, replacement, content)

        # Add nav link if nav-links section exists
        nav_link = f'<Link to="{route_path}" className="nav-link">{component_name.replace("Page", "")}</Link>'
        if 'nav-links' in content and nav_link not in content:
            nav_pattern = r'(</nav>)'
            content = re.sub(nav_pattern, f'          {nav_link}\n        \\1', content)

        app_path.write_text(content)
        output.files_modified.append("src/App.tsx")

    def _create_tests(
        self,
        repo_path: Path,
        component_name: str,
        output: FeatureGeneratorOutput
    ) -> None:
        """Create test files for the component."""

        test_content = f'''import {{ render, screen }} from '@testing-library/react'
import {{ BrowserRouter }} from 'react-router-dom'
import {component_name} from '../pages/{component_name}'

describe('{component_name}', () => {{
  it('renders the page title', () => {{
    render(
      <BrowserRouter>
        <{component_name} />
      </BrowserRouter>
    )

    expect(screen.getByRole('heading', {{ level: 2 }})).toBeInTheDocument()
  }})

  it('renders the feature content', () => {{
    render(
      <BrowserRouter>
        <{component_name} />
      </BrowserRouter>
    )

    expect(screen.getByText(/RSC App Builder/i)).toBeInTheDocument()
  }})
}})
'''

        tests_dir = repo_path / "src" / "__tests__"
        tests_dir.mkdir(parents=True, exist_ok=True)

        test_path = tests_dir / f"{component_name}.test.tsx"
        test_path.write_text(test_content)
        output.files_created.append(f"src/__tests__/{component_name}.test.tsx")
